*** a/server/src/modules/auth/auth.service.ts
--- b/server/src/modules/auth/auth.service.ts
@@
- // Текущая проблема: слабая генерация sub
- const sub = 'u_' + Buffer.from(phone).toString('hex').slice(0, 12);
+ // Безопасная генерация идентификатора пользователя
+ import { randomUUID } from 'crypto';
+ const sub = `usr_${randomUUID()}`;

*** a/server/src/main.ts
--- b/server/src/main.ts
@@
 import { NestFactory } from '@nestjs/core';
 import { AppModule } from './app.module';
+import helmet from 'helmet';
+import * as express from 'express';

 async function bootstrap() {
   const app = await NestFactory.create(AppModule);
+  // Безопасные заголовки
+  app.use(helmet());
+  // Лимиты на размер тела запроса
+  app.use(express.json({ limit: '10mb' }));
+  app.use(express.urlencoded({ extended: true, limit: '10mb' }));
+
+  // Простой readiness endpoint
+  app.getHttpAdapter().getInstance().get('/ready', (_req, res) => res.status(200).send('OK'));
   await app.listen(process.env.PORT || 3000);
 }
 bootstrap();

*** /dev/null
--- b/server/src/middlewares/rate-limit-redis.middleware.ts
@@
+import { Injectable, NestMiddleware, HttpException } from '@nestjs/common';
+import type { Request, Response, NextFunction } from 'express';
+import Redis from 'ioredis';
+
+@Injectable()
+export class RedisRateLimitMiddleware implements NestMiddleware {
+  private redis: Redis;
+  constructor() {
+    this.redis = new Redis(process.env.REDIS_URL || 'redis://redis:6379');
+  }
+  async use(req: Request, _res: Response, next: NextFunction) {
+    const key = `rate_limit:${req.ip}:${req.path}`;
+    const current = await this.redis.incr(key);
+    if (current === 1) await this.redis.expire(key, 60);
+    if (current > 100) throw new HttpException('Rate limit exceeded', 429);
+    next();
+  }
+}
+
*** /dev/null
--- b/server/src/metrics/extended-metrics.service.ts
@@
+import { Injectable } from '@nestjs/common';
+
+@Injectable()
+export class ExtendedMetricsService {
+  private requestDuration = new Map<string, number[]>();
+  observe(method: string, path: string, durationMs: number) {
+    const key = `${method}:${path}`;
+    const arr = this.requestDuration.get(key) ?? [];
+    arr.push(durationMs);
+    this.requestDuration.set(key, arr);
+  }
+  export(): string {
+    const lines: string[] = [];
+    for (const [key, durations] of this.requestDuration.entries()) {
+      if (!durations.length) continue;
+      const sum = durations.reduce((a, b) => a + b, 0);
+      const avg = sum / durations.length;
+      const sorted = [...durations].sort((a, b) => a - b);
+      const p95 = sorted[Math.floor(sorted.length * 0.95)];
+      lines.push(`http_request_duration_ms_avg{key="${key}"} ${avg}`);
+      lines.push(`http_request_duration_ms_p95{key="${key}"} ${p95}`);
+    }
+    return lines.join('\\n');
+  }
+}
+
*** /dev/null
--- b/server/prisma/migrations/20251014_indices.sql
@@
+-- Индексы под частоиспользуемые запросы
+CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_transactions_status_created 
+  ON transactions(status, created_at) WHERE status = 'pending';
+
+CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vouchers_state_expires 
+  ON vouchers(state, expires_at) WHERE state IN ('issued', 'handed_over');
+
*** a/server/package.json
--- b/server/package.json
@@
   "dependencies": {
-    "@nestjs/common": "...",
+    "@nestjs/common": "...",
+    "@nestjs/cache-manager": "^2.0.0",
+    "cache-manager": "^5.4.0",
+    "helmet": "^7.1.0",
+    "ioredis": "^5.4.1"
   }

*** a/infra/docker-compose.prod.yml
--- b/infra/docker-compose.prod.yml
@@
 services:
   api:
     image: deeptea/api:latest
+    healthcheck:
+      test: ["CMD", "curl", "-f", "http://localhost:3000/ready"]
+      interval: 30s
+      timeout: 10s
+      retries: 3
+      start_period: 40s
   postgres:
     image: postgres:16
+    healthcheck:
+      test: ["CMD-SHELL", "pg_isready -U deeptea"]
+      interval: 30s
+      timeout: 10s
+      retries: 3

*** a/infra/nginx/nginx.conf
--- b/infra/nginx/nginx.conf
@@
 http {
+  upstream api {
+    server api:3000;
+    keepalive 32;
+  }
+  limit_req_zone $binary_remote_addr zone=api_zone:10m rate=10r/s;
   server {
     listen 80;
-    location /api/ {
-      proxy_pass http://api:3000/;
-    }
+    location /api/ {
+      limit_req zone=api_zone burst=20 nodelay;
+      proxy_pass http://api;
+      proxy_http_version 1.1;
+      proxy_set_header Connection "";
+    }
     location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
-      expires 7d;
+      expires 1y;
+      add_header Cache-Control "public, immutable";
     }
   }
 }

*** /dev/null
--- b/mobile/src/services/api.ts
@@
+import { CONFIG } from '../config';
+
+const delay = (ms: number) => new Promise(r => setTimeout(r, ms));
+const cryptoRandom = () => Math.random().toString(36).slice(2);
+
+export const api = {
+  async p2pCreate(body: any, retries = 3) {
+    for (let i = 0; i < retries; i++) {
+      try {
+        const res = await fetch(`${CONFIG.API_BASE_URL}/api/p2p/create`, {
+          method: 'POST',
+          headers: {
+            'Content-Type': 'application/json',
+            'Idempotency-Key': `${cryptoRandom()}:${Date.now()}`
+          },
+          body: JSON.stringify(body),
+        });
+        if (!res.ok) throw new Error(`HTTP ${res.status}`);
+        return await res.json();
+      } catch (err) {
+        if (i === retries - 1) throw err;
+        await delay(1000 * Math.pow(2, i)); // 1s, 2s, 4s
+      }
+    }
+  }
+};

*** /dev/null
--- b/mobile/src/services/ble-real.ts
@@
+import { Platform, NativeModules } from 'react-native';
+
+type NearbyDevice = { id: string; name?: string; rssi?: number; eid?: string };
+
+const BLE = NativeModules?.DeepTeaBLE || {
+  startScanning: async () => {},
+  stopScanning: async () => {},
+  onDevice: (cb: (d: NearbyDevice) => void) => { /* no-op mock */ return () => {}; }
+};
+
+const debounce = (fn: any, ms = 300) => {
+  let t: any;
+  return (...args: any[]) => {
+    clearTimeout(t);
+    t = setTimeout(() => fn(...args), ms);
+  };
+};
+
+export const realBLE = {
+  async startScanning(timeoutMs = 30_000) {
+    await BLE.startScanning();
+    setTimeout(() => this.stopScanning(), timeoutMs);
+  },
+  async stopScanning() {
+    await BLE.stopScanning();
+  },
+  onDevice(callback: (device: NearbyDevice) => void) {
+    const seen = new Set<string>();
+    const safeCb = debounce((d: NearbyDevice) => {
+      if (!d?.id) return;
+      if (seen.has(d.id)) return;
+      seen.add(d.id);
+      callback(d);
+    }, 500);
+    return BLE.onDevice(safeCb);
+  },
+};

*** /dev/null
--- b/mobile/src/store/appStore.ts
@@
+import { create } from 'zustand';
+
+type Device = { id: string; name?: string; eid?: string; rssi?: number };
+type State = {
+  devices: Device[];
+  scanState: 'idle' | 'scanning' | 'error';
+  lastError?: string;
+  connectionState: 'disconnected' | 'connecting' | 'connected';
+  addDevice: (d: Device) => void;
+  setScanState: (s: State['scanState']) => void;
+};
+
+const logger =
+  (config: any) =>
+  (set: any, get: any, api: any) =>
+    config((args: any) => {
+      console.log('[store update]', args);
+      set(args);
+    }, get, api);
+
+export const useAppStore = create<State>()(
+  logger((set) => ({
+    devices: [],
+    scanState: 'idle',
+    connectionState: 'disconnected',
+    addDevice: (d) =>
+      set((s: State) => {
+        if (s.devices.find(x => x.id === d.id)) return s;
+        return { ...s, devices: [...s.devices, d] };
+      }),
+    setScanState: (scanState) => set({ scanState }),
+  }))
+);

*** /dev/null
--- b/server/test/integration/p2p-flow.spec.ts
@@
+import request from 'supertest';
+import { INestApplication } from '@nestjs/common';
+// Предполагается, что есть helper для e2e bootstrapping
+declare const app: INestApplication;
+
+describe('P2P Flow Integration', () => {
+  it('completes P2P transaction', async () => {
+    const resolveRes = await request(app.getHttpServer())
+      .post('/api/ble/resolve')
+      .send({ eid: 'TEST-EID' });
+    expect(resolveRes.status).toBeLessThan(500);
+
+    const txRes = await request(app.getHttpServer())
+      .post('/api/p2p/create')
+      .set('Idempotency-Key', `test-${Date.now()}`)
+      .send({ sender_id: 'test-user', receiver_eid: 'TEST-EID', amount: 100 });
+    expect(txRes.status).toBeLessThan(500);
+  });
+});